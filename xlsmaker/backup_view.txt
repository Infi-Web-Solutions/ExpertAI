import pandas as pd
from io import BytesIO, StringIO
from django.shortcuts import render, redirect
from django.http import HttpResponse
from django.contrib import messages
# from langchain.chat_models import ChatOpenAI
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI  # Novo import correto
from langchain_community.chat_models import ChatOpenAI
from csv import reader
import xlsxwriter
from xlsxwriter.utility import xl_col_to_name
import base64
from django.http import JsonResponse
from django.contrib.auth import logout
from django.contrib.sessions.models import Session
import csv
from .models import Solicitacao
from django.contrib.auth.decorators import login_required
from .models import UserProfile
import tiktoken
from django.core.paginator import Paginator
import re
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
import traceback
from django.http import FileResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.uploadedfile import InMemoryUploadedFile
import io
import openpyxl
from .models import FormulaIntelligence
import difflib

# Create your views here.
def logout_view(request):
    # Apaga todas as sess√µes do usu√°rio logado
    if request.user.is_authenticated:
        Session.objects.filter(session_key=request.session.session_key).delete()

    logout(request)  # Encerra a sess√£o atual
    Session.objects.filter(session_key=request.session.session_key).delete()
    return redirect('usuarios:user_login')  # Redireciona para a p√°gina de login

@login_required
def historico_solicitacoes(request):
    solicitacoes_list = Solicitacao.objects.filter(usuario=request.user).order_by('-created_at')  # Ordena do mais recente para o mais antigo
    paginator = Paginator(solicitacoes_list, 10)  # Exibe 5 solicita√ß√µes por p√°gina
    if request.user.is_authenticated:
        solicitacoes_usuario = Solicitacao.objects.filter(usuario=request.user)
    else:
        solicitacoes_usuario = None
    page_number = request.GET.get('page')  # Obt√©m o n√∫mero da p√°gina na URL (?page=1, ?page=2, ...)
    solicitacoes = paginator.get_page(page_number)  # Obt√©m a p√°gina atual
    return render(request, 'historico.html', {'solicitacoes': solicitacoes, 'solicitacoes_usuario':solicitacoes_usuario})


def validacao(request):
    if request.method == 'POST':
        email = request.POST.get('email', '').strip()
        password = request.POST.get('password', '').strip()

        if not email or not password:
            messages.error(request, '‚ùå Por favor, preencha todos os campos.')
            return redirect('xlsmaker:login')

        if email == 'suporte@hire.co.mz' and password == '2020Eraumavez':
            messages.success(request, '‚úÖ Logado com sucesso!')
            return redirect('xlsmaker:dashboard')

        messages.error(request, '‚ùå Email ou senha inv√°lidos.')
        return redirect('xlsmaker:login')

    return redirect('xlsmaker:login')  # Garante que requisi√ß√µes GET n√£o fiquem sem resposta

def dashboard(request):
    # return render(request, 'dashboard.html')
    user_profile = UserProfile.objects.get(user=request.user)
    tokens_disponiveis = user_profile.tokens_atribuidos - user_profile.tokens_gastos
    request.session['tokens_disponiveis'] = tokens_disponiveis  # Atualiza a sess√£o
    if request.user.is_authenticated:
        solicitacoes_usuario = Solicitacao.objects.filter(usuario=request.user)
    else:
        solicitacoes_usuario = None
    return render(request, 'dashboard.html', {
        'solicitacoes_usuario': solicitacoes_usuario,
        'tokens_disponiveis' : tokens_disponiveis
    })

#fun√ß√£o para contar tokens
def contar_tokens(texto, modelo="gpt-4"):
    encoder = tiktoken.encoding_for_model(modelo)
    return len(encoder.encode(texto))


def translate_formulas(formula, language):
    """Traduz e ajusta f√≥rmulas para o idioma e formato correto do Excel."""
    if not isinstance(formula, str) or not formula.startswith("="):
        return formula

    # Cleanup de caracteres problem√°ticos
    formula = formula.replace("=@", "=").replace("= @", "=").strip()


    # Dicion√°rio completo de fun√ß√µes
    excel_functions = {
        "Ingl√™s": {

            "DATA":"DATE",
            "CONCATENAR":"CONCAT",
            "ABS": "ABS",
            "ENDERE√áO": "ADDRESS",
            "AGREGAR": "AGGREGATE",
            "√âERROS": "ISERROR",

            # L√≥gicas
            "E": "AND",
            "OU": "OR",
            "SE": "IF",
            "FALSO": "FALSE",
            "VERDADEIRO": "TRUE",
            "√âERROS": "ISERROR",
            "√âC√âL.VAZIA": "ISBLANK",

            # Matem√°ticas
            "PAR": "EVEN",
            "√çMPAR": "ODD",
            "FATORIAL": "FACT",
            "FATDUPLO": "FACTDOUBLE",
            "PI": "PI",
            "ARRED": "ROUND",
            "TETO": "CEILING",
            "PISO": "FLOOR",
            "MODO": "MODE",

            # Estat√≠sticas
            "CONTAR": "COUNT",
            "CONT.VALORES": "COUNTA",
            "CONTAR.VAZIO": "COUNTBLANK",
            "CONT.SE": "COUNTIF",
            "CONT.SES": "COUNTIFS",
            "M√âDIA": "AVERAGE",
            "M√âDIASE": "AVERAGEIF",
            "M√ÅXIMO": "MAX",
            "M√çNIMO": "MIN",
            "SOMA": "SUM",
            "SOMASE": "SUMIF",
            "SOMASES": "SUMIFS",

            # Texto
            "EXACTO": "EXACT",
            "MIN√öSCULA": "LOWER",
            "MAI√öSCULA": "UPPER",
            "PRI.MAI√öSCULA": "PROPER",
            "EXT.TEXTO": "MID",

            # Data
            "HOJE": "TODAY",
            "AGORA": "NOW",
            "DIA": "DAY",
            "M√äS": "MONTH",
            "ANO": "YEAR",

            # Procura
            "PROCV": "VLOOKUP",
            "PROCH": "HLOOKUP",
            "√çNDICE": "INDEX",
            "CORRESP": "MATCH"

        },
        "Portugu√™s": {

            "DATE":"DATA",
            "CONCAT":"CONCATENAR",
            "ABS": "ABS",
            "ADDRESS": "ENDERE√áO",
            "AGGREGATE": "AGREGAR",
            "ISERROR": "√âERROS",

            # L√≥gicas
            "AND": "E",
            "OR": "OU",
            "IF": "SE",
            "FALSE": "FALSO",
            "TRUE": "VERDADEIRO",
            "ISERROR": "√âERROS",
            "ISBLANK": "√âC√âL.VAZIA",

            # Matem√°ticas
            "EVEN": "PAR",
            "ODD": "√çMPAR",
            "FACT": "FATORIAL",
            "FACTDOUBLE": "FATDUPLO",
            "PI": "PI",
            "ROUND": "ARRED",
            "CEILING": "TETO",
            "FLOOR": "PISO",
            "MODE": "MODO",

            # Estat√≠sticas
            "COUNT": "CONTAR",
            "COUNTA": "CONT.VALORES",
            "COUNTBLANK": "CONTAR.VAZIO",
            "COUNTIF": "CONT.SE",
            "COUNTIFS": "CONT.SES",
            "AVERAGE": "M√âDIA",
            "AVERAGEIF": "M√âDIASE",
            "MAX": "M√ÅXIMO",
            "MIN": "M√çNIMO",
            "SUM": "SOMA",
            "SUMIF": "SOMASE",
            "SUMIFS": "SOMASES",

            # Texto
            "EXACT": "EXACTO",
            "LOWER": "MIN√öSCULA",
            "UPPER": "MAI√öSCULA",
            "PROPER": "PRI.MAI√öSCULA",
            "MID": "EXT.TEXTO",

            # Data
            "TODAY": "HOJE",
            "NOW": "AGORA",
            "DAY": "DIA",
            "MONTH": "M√äS",
            "YEAR": "ANO",

            # Procura
            "VLOOKUP": "PROCV",
            "HLOOKUP": "PROCH",
            "INDEX": "√çNDICE",
            "MATCH": "CORRESP"
        }
    }

    # Selecionar dire√ß√£o da tradu√ß√£o
    translation_dict = excel_functions.get(language, {})

    # Ordenar fun√ß√µes por tamanho (para evitar substitui√ß√µes parciais)
    func_list = sorted(
        translation_dict.items(),
        key=lambda x: len(x[0]),
        reverse=True
    )

    # Substitui√ß√£o usando regex para match exato
    for source_func, target_func in func_list:
        formula = re.sub(
            r'(?i)\b' + re.escape(source_func) + r'\b', # Case insensitive
            target_func,
            formula
        )

    # Corrigir refer√™ncias de coluna quebradas (ex: AND:AND -> A:A)
    formula = re.sub(
        r'([A-Z]+):\1',
        lambda m: f'{m.group(1)[0]}:{m.group(1)[0]}',
        formula
    )


    # Substituir separadores de argumentos
    separator = ',' if language == "Ingl√™s" else ';'
    opposite_sep = ';' if language == "Ingl√™s" else ','
    formula = formula.replace(opposite_sep, separator)

    if language == "Ingl√™s":
        if re.search(r'\bSUMIF\b', formula, re.IGNORECASE) and formula.count(',') > 2:
            formula = re.sub(r'\bSUMIF\b', "SUMIFS", formula, flags=re.IGNORECASE)
    elif language == "Portugu√™s":
        if re.search(r'\bSOMASE\b', formula, re.IGNORECASE) and formula.count(';') > 2:
            formula = re.sub(r'\bSOMASE\b', "SOMASES", formula, flags=re.IGNORECASE)


    # Garantir formata√ß√£o de texto com aspas
    formula = re.sub(
        r'=([^"]*)(\")([^"]+)(\")([^"]*)',
        r'=\1"\3"\5',
        formula
    )

    return formula

def parse_sheet_data(data, language):
    """Processa dados de uma aba lidando com f√≥rmulas complexas"""
    reader = csv.reader(
        StringIO(data),
        delimiter=',',
        quotechar='"',
        escapechar='\\'
    )

    rows = list(reader)
    if not rows:
        return pd.DataFrame()

    headers = rows[0]
    cleaned_rows = []

    for row in rows[1:]:
        if len(row) == len(headers):
            cleaned_rows.append(row)
            continue

        # Reconstruir linhas com f√≥rmulas quebradas
        reconstructed = []
        formula_buffer = []
        for cell in row:
            if cell.startswith('=') and not cell.endswith('"'):
                formula_buffer.append(cell)
            elif formula_buffer:
                formula_buffer.append(cell)
                if cell.endswith('"'):
                    reconstructed.append(','.join(formula_buffer).strip('"'))
                    formula_buffer = []
            else:
                reconstructed.append(cell)

        if len(reconstructed) == len(headers):
            cleaned_rows.append(reconstructed)

    df = pd.DataFrame(cleaned_rows, columns=headers)
    tradutor = FormulaIntelligence()  # inst√¢ncia da sua classe

    # Traduzir e normalizar f√≥rmulas
    for col in df.columns:
        df[col] = df[col].apply(
            lambda x: (
                # Normalizar f√≥rmula antes da tradu√ß√£o
                re.sub(r'=([A-Za-z]+)', lambda m: f'={m.group(1).upper()}',
                    tradutor.translate_formulas(x, language)
                ) if isinstance(x, str) and x.startswith('=') else x
            )
        )

    return df
def parse_sheet_data_para_upload(data, language):
    """Processa dados de uma aba, lidando com f√≥rmulas e ajustando idioma."""

    delimiter = ';' if language.lower() == "portugu√™s" else ','

    reader = csv.reader(
        StringIO(data),
        delimiter=delimiter,
        quotechar='"',
        escapechar='\\'
    )

    rows = list(reader)
    if not rows:
        return pd.DataFrame()

    headers = rows[0]
    cleaned_rows = []

    for row in rows[1:]:
        row = row + [''] * (len(headers) - len(row))  # Preenche com vazio, se necess√°rio

        reconstructed = []
        formula_buffer = []
        for cell in row:
            if cell.startswith('=') and not cell.endswith('"'):
                formula_buffer.append(cell)
            elif formula_buffer:
                formula_buffer.append(cell)
                if cell.endswith('"'):
                    reconstructed.append(','.join(formula_buffer).strip('"'))
                    formula_buffer = []
            else:
                reconstructed.append(cell)

        if len(reconstructed) != len(headers):
            reconstructed = row
        cleaned_rows.append(reconstructed)

    df = pd.DataFrame(cleaned_rows, columns=headers)

    # Traduzir f√≥rmulas conforme o idioma
    for col in df.columns:
        df[col] = df[col].apply(
            lambda x: translate_formulas(x, language) if isinstance(x, str) and x.startswith('=') else x
        )

    return df


def convert_numeric_columns(df):
    for col in df.columns:
        # Tenta converter para num√©rico
        df[col] = pd.to_numeric(df[col], errors='ignore')
        # Se a convers√£o funcionar, aplica o tipo correto
        if pd.api.types.is_numeric_dtype(df[col]):
            df[col] = df[col].astype('Int64')  # Permite valores nulos
    return df




def processar_formatacao(user_input, buffer, processed_sheets):
    regras = extrair_regras_formatacao(user_input)
    if regras:
        buffer = aplicar_regras_excel(regras, buffer, processed_sheets)
    return buffer

def extrair_regras_formatacao(texto):
    """
    Vers√£o melhorada com padr√µes espec√≠ficos para compara√ß√µes num√©ricas
    """
    regras = []
    padroes = [
        # Linhas - Condi√ß√µes num√©ricas
        {
            'regex': r'(pintar|colorir) (linhas) (?:onde|quando) "?([\w\s]+)"? (√© maior que|√© menor que|>=|<=|>|<|acima de|abaixo de) ([\d]+) (?:com|em) (vermelho|amarelo|verde|azul)',
            'groups': ['acao', 'escopo', 'campo', 'operador', 'valor', 'cor']
        },
        # Colunas - Condi√ß√µes num√©ricas
        {
            'regex': r'(pintar|colorir) (coluna) "?([\w\s]+)"? (?:que|onde) (√© maior que|√© menor que|>=|<=|>|<|acima de|abaixo de) ([\d]+) (?:com|em) (vermelho|amarelo|verde|azul)',
            'groups': ['acao', 'escopo', 'alvo', 'operador', 'valor', 'cor']
        },
        # Linhas - Condi√ß√µes textuais
        {
            'regex': r'(pintar|colorir) (linhas) (?:onde|quando) "?([\w\s]+)"? (cont√©m|√© igual a) "(.*?)" (?:com|em) (vermelho|amarelo|verde|azul)',
            'groups': ['acao', 'escopo', 'campo', 'operador', 'valor', 'cor']
        },
        # Colunas - Condi√ß√µes textuais
        {
            'regex': r'(pintar|colorir) (coluna) "?([\w\s]+)"? (?:que|onde) (cont√©m|√© igual a) "(.*?)" (?:com|em) (vermelho|amarelo|verde|azul)',
            'groups': ['acao', 'escopo', 'alvo', 'operador', 'valor', 'cor']
        }
    ]

    for padrao in padroes:
        matches = re.finditer(padrao['regex'], texto, re.IGNORECASE | re.UNICODE)
        for match in matches:
            grupos = match.groups()
            regra = {k: v.strip().lower() if v else '' for k, v in zip(padrao['groups'], grupos)}
            regras.append(processar_regra(regra))

    return [r for r in regras if r]

def processar_regra(regra):
    mapeamento = {
        '√© maior que': '>', 'acima de': '>',
        '√© menor que': '<', 'abaixo de': '<',
        'cont√©m': 'in', '√© igual a': '=='
    }
    regra['operador'] = mapeamento.get(regra['operador'].lower(), regra['operador'])

    # Convers√£o de valor para num√©rico se aplic√°vel
    if regra['operador'] in ['>', '<', '>=', '<='] and str(regra['valor']).isdigit():
        regra['valor'] = int(regra['valor'])

    return regra


def aplicar_regras_excel(regras, buffer, processed_sheets):
    wb = load_workbook(buffer)
    cores = {"vermelho": "FF0000", "amarelo": "FFFF00", "verde": "00FF00", "azul": "0000FF"}

    for sheet_name, df in processed_sheets:
        if sheet_name not in wb.sheetnames:
            continue

        ws = wb[sheet_name]

        # Remover espa√ßos extras dos nomes das colunas
        df.columns = df.columns.str.strip()

        for regra in regras:
            try:
                col_condicao = None

                # Determinar a coluna correta
                if regra['escopo'] == 'linhas':
                    col_condicao = next((col for col in df.columns if regra['campo'].strip().lower() == col.strip().lower()), None)
                elif regra['escopo'] == 'coluna':
                    col_condicao = next((col for col in df.columns if regra['alvo'].strip().lower() == col.strip().lower()), None)

                if not col_condicao:
                    continue

                # Converter para num√©rico se necess√°rio
                if regra['operador'] in ['>', '<', '>=', '<=']:
                    df[col_condicao] = pd.to_numeric(df[col_condicao], errors='coerce')

                # Construir m√°scara condicional
                mask = None
                if regra['operador'] in ['>', '<', '>=', '<=']:
                    mask = df[col_condicao].apply(lambda x: eval(f"x {regra['operador']} {regra['valor']}") if pd.notnull(x) else False)
                elif regra['operador'] == 'in':
                    mask = df[col_condicao].astype(str).str.contains(regra['valor'], case=False, na=False)
                elif regra['operador'] == '==':
                    mask = df[col_condicao].astype(str) == str(regra['valor'])

                if mask is None:
                    continue

                fill = PatternFill(start_color=cores[regra['cor']], end_color=cores[regra['cor']], fill_type="solid")

                # Aplica√ß√£o de formata√ß√£o condicional
                if regra['escopo'] == 'linhas':
                    for row in df[mask].index:
                        excel_row = row + 2  # Ajuste para cabe√ßalho
                        for col in range(1, len(df.columns) + 1):
                            ws.cell(row=excel_row, column=col).fill = fill

                elif regra['escopo'] == 'coluna':
                    col_idx = df.columns.get_loc(col_condicao) + 1
                    for row in range(2, len(df) + 2):  # Pula cabe√ßalho
                        ws.cell(row=row, column=col_idx).fill = fill

            except Exception as e:
                print(f"Erro ao processar regra {regra}: {str(e)}")

    # Garantir que o buffer seja salvo corretamente
    buffer_corrigido = BytesIO()
    wb.save(buffer_corrigido)
    buffer_corrigido.seek(0)

    return buffer_corrigido


def extrair_colunas_grafico(user_input, colunas_disponiveis):
    texto = user_input.lower()

    padroes = [

        r'eixo x.*?\s*(.*?)\s*(?:e|,)?\s*eixo y.*?\s*(.*?)(?:\.|$)',
        r'onde o eixo x.*?\s*(.*?)\s*(?:e|,)?\s*o eixo y.*?\s*(.*?)(?:\.|$)',
        r'gr[a√°]fico de (.*?) por (.*?)(?:\.|$)',
        r'gr[a√°]fico (.*?) por (.*?)(?:\.|$)',
        r'relaciona\s+(.*?)\s+por\s+(.*?)(?:\.|$)',
        r'representa\s+(.*?)\s+por\s+(.*?)(?:\.|$)',
        r'compara(?:ndo)?\s+(.*?)\s+(?:com|por)\s+(.*?)(?:\.|$)',
        r'mostra\s+(.*?)\s+por\s+(.*?)(?:\.|$)',
        r'exibe\s+(.*?)\s+por\s+(.*?)(?:\.|$)',
        r'exibe\s+(.*?)\s+ao longo\s+(.*?)(?:\.|$)',
        r'(.*?)\s+versus\s+(.*?)(?:\.|$)',
        r'(.*?)\s+vs\s+(.*?)(?:\.|$)',
        r'mostra\s+(.*?)\s+com\s+base\s+em\s+(.*?)(?:\.|$)',
        r'distribui[c√ß][a√£]o\s+de\s+(.*?)\s+por\s+(.*?)(?:\.|$)',
        r'distribui[c√ß][a√£]o\s+de\s+(.*?)\s+entre\s+(.*?)(?:\.|$)',
        r'compara√ß√£o\s+entre\s+(.*?)\s+e\s+(.*?)(?:\.|$)',
        r'relaciona\s+(.*?)\s+(?:por|ao longo d[aoe]|em fun[c√ß]√£o de|de acordo com|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'exibe\s+(.*?)\s+(?:por|ao longo d[aoe]|em fun[c√ß]√£o de|de acordo com|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'mostra\s+(.*?)\s+(?:por|ao longo d[aoe]|em fun[c√ß]√£o de|de acordo com|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'compara(?:ndo)?\s+(.*?)\s+(?:com|por|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'(?:relaciona|correlaciona|associa)\s+(.*?)\s+(?:por|com|ao longo de|em fun[c√ß]√£o de|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'quero (?:ver|um gr[a√°]fico que mostra)\s+(.*?)\s+(?:por|ao longo de|contra|vs|versus|em fun[c√ß]√£o de)\s+(.*?)(?:\.|$)',
        r'(?:quero(?: um)?|gera(?:-me)?|cria(?:-me)?|plota(?:-me)?)\s+(?:ver\s+)?(?:um\s+)?gr[a√°]fico(?: que mostra)?\s+(.*?)\s+(?:por|ao longo de|contra|vs|versus|em fun[c√ß]√£o de)\s+(.*?)(?:\.|$)'
        r'desejo um gr[a√°]fico (.*?) por (.*?)(?:\.|$)',
        r'mostra\s+(.*?)\s+(?:por|ao longo de|em fun[c√ß]√£o de|de acordo com|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'exibe\s+(.*?)\s+(?:por|ao longo de|em fun[c√ß]√£o de|de acordo com|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'demonstra\s+(.*?)\s+(?:por|ao longo de|em fun[c√ß]√£o de|de acordo com|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'compara(?:ndo)?\s+(.*?)\s+(?:com|por|contra|versus|vs)\s+(.*?)(?:\.|$)',
        r'comparativo entre\s+(.*?)\s+e\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico\s+(?:de)?\s*(.*?)\s+por\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico\s+(.*?)\s+ao longo de\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico\s+(.*?)\s+em fun[c√ß]√£o de\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico\s+(.*?)\s+contra\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico\s+(.*?)\s+versus\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico\s+(.*?)\s+vs\s+(.*?)(?:\.|$)',
        r'gr[a√°]fico que mostra\s+(.*?)\s+para cada\s+(.*?)(?:\.|$)',
        r'(?:quero(?: um)?|gera(?:-me)?|cria(?:-me)?)\s+gr[a√°]fico(?: que mostra)?\s+(.*?)\s+para cada\s+(.*?)(?:\.|$)',
    ]

    artigos = {'a', 'as', 'o', 'os', 'um', 'uns', 'uma', 'umas'}
    def remove_leading_article(s):
        parts = s.split()
        if parts and parts[0] in artigos:
            return ' '.join(parts[1:]).strip()
        return s.strip()

    for padrao in padroes:
        match = re.search(padrao, texto)
        if match:
            cand1 = match.group(1).strip().lower()
            cand2 = match.group(2).strip().lower()

            # Remove leading articles
            cand1 = remove_leading_article(cand1)
            cand2 = remove_leading_article(cand2)

            # Tentar como cand1 = y, cand2 = x
            col_x = next((col for col in colunas_disponiveis if cand2 in col.lower()), None)
            col_y = next((col for col in colunas_disponiveis if cand1 in col.lower()), None)
            if col_x and col_y:
                return col_x, col_y

            # Tentar como cand1 = x, cand2 = y
            col_x = next((col for col in colunas_disponiveis if cand1 in col.lower()), None)
            col_y = next((col for col in colunas_disponiveis if cand2 in col.lower()), None)
            if col_x and col_y:
                return col_x, col_y

    return None, None

def contem_pedido_grafico(texto):
    texto = texto.lower()
    termos = ['gr√°fico', 'quero ver', 'mostrar rela√ß√£o', 'representa√ß√£o', 'compara√ß√£o', 'visualizar', 'plotar', 'exibe']
    return any(termo in texto for termo in termos)

def extrair_tipo_grafico(user_input):
    tipos = {
        'coluna': 'column',
        'barra': 'bar',
        'linha': 'line',
        'pizza': 'pie',
        'dispers√£o': 'scatter',
        '√°rea': 'area',
        'colunas': 'column',
        'barras': 'bar',
        'linhas': 'line'
    }
    for chave, valor in tipos.items():
        if chave in user_input.lower():
            return valor
    return 'column'  # padr√£o


def corrigir_formula_string(valor):
    if isinstance(valor, str):
        match = re.match(r'^="\s*(=.+)"$', valor)
        if match:
            return match.group(1)
    return valor




def corrigir_formula_erro_ia(formula: str, idioma='en', abas_existentes=None) -> str:
    if not isinstance(formula, str):
        return formula


    # Remove o "@" antes de fun√ß√µes (ex: @SOMA ‚Üí SOMA)
    formula = re.sub(r'@(?=\w+\()', '', formula)

    # Normaliza o idioma
    idioma = idioma.strip().lower()


    if idioma.startswith('pt'):
        # Tradu√ß√µes do ingl√™s para o portugu√™s
        formula = formula.replace('SUMIFS', 'SOMASES')
        formula = formula.replace('SUMIF', 'SOMASE')
        formula = formula.replace('IF', 'SE')
        # Corrige estrutura: SOMASE - SOMASE ‚Üí SOMASES - SOMASES
        formula = re.sub(
            r"SOMASE\(([^,;]+)[,;]([^,;]+)[,;]([^)]+)\)\s*-\s*SOMASE\(([^,;]+)[,;]([^,;]+)[,;]([^)]+)\)",
            r"SOMASES(\3;\1;\2)-SOMASES(\6;\4;\5)",
            formula
        )
    else:
        # Tradu√ß√µes do portugu√™s para o ingl√™s (caso o usu√°rio tenha misturado idiomas)
        formula = formula.replace('SOMASES', 'SUMIFS')
        formula = formula.replace('SOMASE', 'SUMIF')
        formula = formula.replace('SE', 'IF')
        # Corrige estrutura: SUMIF - SUMIF ‚Üí SUMIFS - SUMIFS
        formula = re.sub(
            r"SUMIF\(([^,]+),([^,]+),([^)]+)\)\s*-\s*SUMIF\(([^,]+),([^,]+),([^)]+)\)",
            r"SUMIFS(\3,\1,\2)-SUMIFS(\6,\4,\5)",
            formula
        )
    tradutor = FormulaIntelligence()
    return tradutor.corrigir_formulas_comuns(
        formula=formula,
        idioma=idioma,
        abas_existentes=abas_existentes
    )



def generate_spreadsheet_view(request):
    prompt_template = PromptTemplate.from_template(
        """
         Descri√ß√£o do Usu√°rio:
        "{user_input}"

                    Voc√™ √© uma IA especialista em Excel avan√ßado. Sua tarefa √© gerar uma planilha completa com base em uma descri√ß√£o fornecida. A planilha deve ser estruturada de forma profissional, conter dados realistas, f√≥rmulas inteligentes e, quando solicitado, dashboards interativos e segmenta√ß√µes din√¢micas.

            ---

             Instru√ß√µes:

            1. **Formato de sa√≠da**
            - Utilize blocos separados por `Sheet: NOME_DA_ABA` para representar m√∫ltiplas abas
            - Cada aba deve estar em **formato CSV** com **cabe√ßalhos na primeira linha**
            - Separe diferentes planilhas com uma linha em branco

            2. **Dados fict√≠cios**
            - Gere **10 registros realistas por aba**
            - Os dados devem ser coerentes entre abas e simular situa√ß√µes de neg√≥cios reais

            3. **F√≥rmulas**
            - Utilize **refer√™ncias relativas** (ex: `B2`, `C3`)
            - Use **idioma coerente com o conte√∫do (PT ou EN)**
                - PT: `M√âDIA`, `SE`, `SOMASE`
                - EN: `AVERAGE`, `IF`, `SUMIF`
            - Utilize `;` como separador para PT e `,` para EN
            - Caso a f√≥rmula contenha separadores, envolva com aspas
                - Ex: `=SE(D2>=14;"Aprovado";"Reprovado")`

            4. **Relacionamento entre abas**
            - Quando poss√≠vel, conecte dados entre abas com **PROCV/XLOOKUP** ou **√çNDICE/CORRESP**
            - Exemplo: use a aba de Produtos para trazer pre√ßos para a aba de Vendas

            5. **Recursos avan√ßados (se aplic√°vel √† descri√ß√£o do usu√°rio)**
            - Adicione uma aba com uma **tabela din√¢mica resumida**
            - Adicione uma aba com um **dashboard visual** contendo:
                - Gr√°ficos din√¢micos (colunas, pizza, linhas, barras)
                - Segmenta√ß√µes por filtros (ex: M√™s, Regi√£o, Produto)
                - Indicadores (KPIs), como Total de Vendas, Meta, Ticket M√©dio

            6. **Gr√°ficos (simula√ß√£o textual)**
            - Descreva os gr√°ficos gerados com:
                - Tipo de gr√°fico (colunas, pizza, etc.)
                - Eixos (X e Y)
                - Segmenta√ß√µes/filtros utilizados
            - Prefixe com `Gr√°fico:`. Exemplo:
                ```
                Gr√°fico:
                Tipo: Colunas
                Eixo X: M√™s
                Eixo Y: Receita Total
                Slicer: Regi√£o
                ```

            7. **Exemplo de estrutura de resposta**

            Sheet: Vendas ID Venda,Data,Cliente,Produto,Quantidade,Pre√ßo Unit√°rio,Total 001,01/04/2024,Carlos,Notebook,2,3500,"=E2*F2" ...
            Sheet: Produtos Produto,Categoria,Estoque Notebook,Inform√°tica,50 ...
            Sheet: Resumo Produto,Total Vendido,Receita Total Notebook,"=SOMASE(Vendas!D:D,A2,Vendas!G:G)","=SOMASE(Vendas!D:D,A2,Vendas!G:G)"
            Gr√°fico: Tipo: Colunas Eixo X: Produto Eixo Y: Receita Total Slicer: M√™s

            ---

             Descri√ß√£o fornecida pelo usu√°rio:
            "{user_input}"

            ---
             Tarefa: Gere a estrutura da planilha conforme as instru√ß√µes acima, preenchendo com dados coerentes e estruturando corretamente as f√≥rmulas e rela√ß√µes entre abas.

        """
    )

    if request.method == 'POST':
        try:
            user_input = request.POST.get('user_input', '')
            file_name = request.POST.get('nome_da_planilha', 'planilha')[:50]
            excel_language = request.POST.get('idioma_selecionado', 'Ingl√™s')

            tokens_estimados = contar_tokens(user_input)
            # Verifica se o usu√°rio tem tokens suficientes antes de chamar a API
            user_profile = UserProfile.objects.get(user=request.user)
            # tokens_disponiveis = user_profile.tokens_atribuidos - user_profile.tokens_gastos
            request.session['tokens_disponiveis'] = user_profile.tokens_atribuidos - user_profile.tokens_gastos

            if request.session['tokens_disponiveis']  < tokens_estimados:
                messages.error(request, "Voc√™ n√£o tem tokens suficientes para essa solicita√ß√£o.")
                return redirect("xlsmaker:generate-spreadsheet")

            solicitacao = Solicitacao(
                usuario=request.user,
                nome=request.user.username,
                email=request.user.email,
                descricao=user_input
            )
            solicitacao.save()

            # Gerar resposta da IA
            model = ChatOpenAI(model='gpt-4', temperature=0.2)
            response = model.predict(prompt_template.format(user_input=user_input))

             # Captura a quantidade real de tokens usados na requisi√ß√£o
            tokens_gerados = tokens_estimados
            # Deduz os tokens gastos e salva no usu√°rio
            user_profile.tokens_gastos += tokens_gerados
            user_profile.save()
            
            # Processar m√∫ltiplas abas
            sheets = []
            current_sheet = {'name': 'Principal', 'data': []}

            for line in response.strip().split('\n'):
                line = line.strip()
                if line.startswith('Sheet: '):
                    if current_sheet['data']:
                        sheets.append(current_sheet)
                    current_sheet = {
                        'name': line[len('Sheet: '):].strip()[:31],
                        'data': []
                    }
                else:
                    current_sheet['data'].append(line)

            if current_sheet['data']:
                sheets.append(current_sheet)

            # Extrair os nomes das abas antes de processar as f√≥rmulas
            # abas_existentes = [sheet['name'] for sheet in sheets if 'name' in sheet]
            # Processar cada aba
            # processed_sheets = []
            processed_sheets = []
            abas_existentes = [sheet['name'] for sheet in sheets if 'name' in sheet]

        

            for sheet in sheets:
                if not sheet['data']:
                    continue
                # Processa os dados da aba
                df = parse_sheet_data('\n'.join(sheet['data']), excel_language)
                # Aplica corre√ß√µes nas f√≥rmulas
                for col in df.columns:
                    df[col] = df[col].apply(
                        lambda x: (
                            corrigir_formula_erro_ia(
                                x,
                                idioma=excel_language,
                                abas_existentes=abas_existentes
                            ) if isinstance(x, str) and x.startswith('=') else x
                        )
                    )

                # Mantido: Convers√£o para num√©rico
                for col in df.columns:
                    df[col] = pd.to_numeric(df[col], errors='ignore')

                processed_sheets.append((sheet['name'], df))  # Append corrigido


            # Fallback para planilha √∫nica
            # if not processed_sheets:
            #     df = parse_sheet_data(response.strip(), excel_language)
            #     if not df.empty:
            #         for col in df.columns:
            #         #    df[col] = df[col].apply(corrigir_formula_string)
            #             df[col] = df[col].apply(lambda x: corrigir_formula_erro_ia(x, excel_language, abas_existentes))
            #         for col in df.columns:
            #             df[col] = pd.to_numeric(df[col], errors='ignore')
            #         processed_sheets.append(('Planilha Principal', df))
            #     else:
            #         raise ValueError("Nenhum dado v√°lido encontrado na resposta da IA")

            # Fallback para planilha √∫nica
            if not processed_sheets:
                df = parse_sheet_data(response.strip(), excel_language)
                if not df.empty:
                    # Neste ponto, s√≥ h√° uma aba "Planilha Principal"
                    abas_existentes = ['Planilha Principal']

                    for col in df.columns:
                        df[col] = df[col].apply(lambda x: corrigir_formula_erro_ia(x, excel_language, abas_existentes))
                    for col in df.columns:
                        df[col] = pd.to_numeric(df[col], errors='ignore')
                    processed_sheets.append(('Planilha Principal', df))
                else:
                    raise ValueError("Nenhum dado v√°lido encontrado na resposta da IA")

            # Gerar arquivo Excel
            buffer = BytesIO()
            with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
                for sheet_name, df in processed_sheets:
                    df.to_excel(
                        writer,
                        index=False,
                        sheet_name=sheet_name,
                        header=True
                    )
                    worksheet = writer.sheets[sheet_name]
                    worksheet.autofilter(0, 0, len(df), len(df.columns)-1)
                    # Aplicar formata√ß√£o num√©rica
                    number_format = writer.book.add_format({'num_format': '0'})
                    for idx, col in enumerate(df.columns):
                        if pd.api.types.is_numeric_dtype(df[col]):
                            worksheet.set_column(idx, idx, None, number_format)


                    # Detectar gr√°fico com base na descri√ß√£o do usu√°rio
                    if contem_pedido_grafico(user_input):
                        try:
                            # 1. Garantir que trabalhamos apenas com a aba principal
                            main_sheet = processed_sheets[0]  # Pega a primeira e √∫nica aba de dados
                            sheet_name, df = main_sheet
                            colunas = df.columns.tolist()
                            eixo_x, eixo_y = extrair_colunas_grafico(user_input, colunas)

                            if eixo_x and eixo_y:
                                # 3. Determinar tipo de gr√°fico de forma definitiva
                                x_type = 'categorical' if df[eixo_x].dtype == 'object' else 'numerical'
                                y_type = 'numerical' if pd.api.types.is_numeric_dtype(df[eixo_y]) else 'categorical'

                                # L√≥gica aprimorada para tipo de gr√°fico
                                chart_type = 'column'
                                if x_type == 'categorical' and y_type == 'numerical':
                                    chart_type = 'column'
                                elif x_type == 'numerical' and y_type == 'numerical':
                                    chart_type = 'scatter'
                                elif x_type == 'categorical' and y_type == 'categorical':
                                    chart_type = 'bar'

                                # 4. Criar aba exclusiva para o gr√°fico
                                chart_sheet_name = "An√°lise Gr√°fica"  # Nome fixo
                                chart_worksheet = writer.book.add_worksheet(chart_sheet_name)

                                # 5. Configurar gr√°fico
                                chart_type = extrair_tipo_grafico(user_input)
                                chart = writer.book.add_chart({'type': chart_type})
                                chart.add_series({
                                    'name': f'{eixo_y}',
                                    'categories': [sheet_name, 1, df.columns.get_loc(eixo_x), len(df), df.columns.get_loc(eixo_x)],
                                    'values': [sheet_name, 1, df.columns.get_loc(eixo_y), len(df), df.columns.get_loc(eixo_y)],
                                    'gap': 150 if chart_type == 'column' else None
                                })

                                # 6. Ajustes de layout profissional
                                chart.set_title({
                                    'name': f'{eixo_y} por {eixo_x}',
                                    'name_font': {'size': 14, 'bold': True}
                                })
                                chart.set_x_axis({
                                    'name': eixo_x,
                                    'name_font': {'size': 12},
                                    'num_font': {'size': 10},
                                    'text_axis': x_type == 'categorical'
                                })
                                chart.set_y_axis({
                                    'name': eixo_y,
                                    'name_font': {'size': 12},
                                    'num_font': {'size': 10},
                                    'major_gridlines': {'visible': True}
                                })

                                # 7. Posicionamento centralizado na aba
                                chart_worksheet.insert_chart('B2', chart)
                                chart_worksheet.set_zoom(85)  # Zoom ideal para visualiza√ß√£o

                                # 8. Remover abas extras se necess√°rio
                                if len(processed_sheets) > 1:
                                    processed_sheets = [processed_sheets[0]]  # Mant√©m apenas a principal

                            else:
                                print("[INFO] Nenhum gr√°fico gerado - eixos n√£o identificados no texto.")
                        except Exception as e:
                            print(f"[ERRO] Falha ao gerar gr√°fico: {e}")

            try:
                buffer = aplicar_regras_excel(
                    extrair_regras_formatacao(user_input),
                    buffer,
                    processed_sheets
                )
            except Exception as e:
                messages.warning(request, f"Erro na formata√ß√£o: {str(e)}")
                print(f"DEBUG - Erro detalhado: {traceback.format_exc()}")


            # Preparar resposta final
            buffer.seek(0)
            request.session['excel_file'] = {
                'content': base64.b64encode(buffer.getvalue()).decode('utf-8'),
                'file_name': f"{file_name}.xlsx"
            }


            if request.user.is_authenticated:
                solicitacoes_usuario = Solicitacao.objects.filter(usuario=request.user)
            else:
                solicitacoes_usuario = None
            context = {
                'preview_data': processed_sheets[0][1].head().to_dict('records'),
                'headers': processed_sheets[0][1].columns.tolist(),
                'num_sheets': len(processed_sheets),
                'tokens_disponiveis' :  request.session['tokens_disponiveis'],
                'solicitacoes_usuario': solicitacoes_usuario,
            }

            messages.success(request, f'‚úÖ Planilha gerada com {len(processed_sheets)} abas!')
            return render(request, 'dashboard.html', context)

        except Exception as e:
            messages.error(request, f'‚ùå Erro: {str(e)}')
            return render(request, 'dashboard.html')
        # context={'tokens_disponiveis' :  tokens_disponiveis}
    return render(request, 'dashboard.html')


def download_spreadsheet_view(request):
    file_data = request.session.get('excel_file')

    if file_data:
        try:
            # Decodifica os dados base64
            excel_data = base64.b64decode(file_data['content'])

            # Remove a sess√£o ap√≥s o download
            del request.session['excel_file']

            # Retorna o arquivo para download
            response = HttpResponse(
                excel_data,
                content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            )
            response['Content-Disposition'] = f'attachment; filename="{file_data["file_name"]}"'
            return response

        except Exception as e:
            messages.error(request, f"Erro ao gerar a planilha: {str(e)}")
            return redirect('xlsmaker:generate-spreadsheet')

    # Se n√£o houver arquivo na sess√£o, retorna erro
    messages.error(request, 'Nenhum arquivo dispon√≠vel para download')
    return redirect('xlsmaker:generate-spreadsheet')

def clear_preview(request):
    if request.method == 'POST':
        # Limpar dados da sess√£o
        keys_to_remove = ['excel_file', 'preview_data', 'headers', 'charts']
        for key in keys_to_remove:
            if key in request.session:
                del request.session[key]

        if request.user.is_authenticated:
            solicitacoes_usuario = Solicitacao.objects.filter(usuario=request.user)
        else:
            solicitacoes_usuario = None
        messages.info(request, 'üöÆ Pr√©-visualiza√ß√£o limpa com sucesso!')
        context={'solicitacoes_usuario':solicitacoes_usuario}
    return render(request,'dashboard.html', context)



def carregar_planilha_dinamica(planilha):
    conteudo = planilha.read().decode('utf-8').splitlines()

    for i, linha in enumerate(conteudo):
        colunas = linha.split(',')
        if len(colunas) > 1 and all(col.strip() != '' for col in colunas):
            primeira_linha_valida = i
            break

    planilha.seek(0)
    df = pd.read_csv(planilha, skiprows=primeira_linha_valida)
    return df


def carregar_excel_dinamico(planilha):
    wb = openpyxl.load_workbook(planilha, data_only=True)
    ws = wb.active

    primeira_linha_valida = 0

    for i, row in enumerate(ws.iter_rows(values_only=True), start=0):
        # Verifica se h√° pelo menos uma c√©lula n√£o vazia na linha
        if any(cell is not None and str(cell).strip() != '' for cell in row):
            primeira_linha_valida = i
            break

    planilha.seek(0)
    df = pd.read_excel(planilha, skiprows=primeira_linha_valida)

    # Remover colunas totalmente vazias
    df = df.dropna(axis=1, how='all')

    # Renomear colunas para remover poss√≠veis Unnamed
    df = df.rename(columns=lambda col: col.replace('Unnamed: ', '') if 'Unnamed' in str(col) else col)

    return df




@csrf_exempt
def upload_planilha(request):
    global planilha_modificada

    if request.method == 'POST':
        planilha = request.FILES.get('planilha')
        descricao = request.POST.get('descricao', '').strip()

        if not planilha or not descricao:
            return JsonResponse({'error': 'Envio inv√°lido.'}, status=400)

        try:
            # Leitura da planilha original
            if planilha.name.endswith('.csv'):
                # df = pd.read_csv(planilha)
                df = carregar_planilha_dinamica(planilha)
            else:
                df = carregar_excel_dinamico(planilha)

            # Converter o dataframe para CSV (string)
            csv_buffer = io.StringIO()
            df.to_csv(csv_buffer, index=False)
            csv_str = csv_buffer.getvalue()

            # Verifica e consome tokens do usu√°rio
            user_profile = UserProfile.objects.get(user=request.user)
            tokens_disponiveis = user_profile.tokens_atribuidos - user_profile.tokens_gastos
            tokens_estimados = contar_tokens(descricao + csv_str)

            if tokens_disponiveis < tokens_estimados:
                return JsonResponse({'error': 'Voc√™ n√£o tem tokens suficientes para essa solicita√ß√£o.'}, status=403)

            # Construir prompt da IA
            prompt = PromptTemplate.from_template("""
                        Voc√™ √© um assistente inteligente para manipula√ß√£o de planilhas. O usu√°rio enviou uma planilha com os seguintes dados em CSV:
                        {csv_str}
                        E fez o seguinte pedido:
                        "{descricao}"
                        Responda com um CSV modificado de acordo com o pedido do usu√°rio, mantendo o cabe√ßalho. Use ";" como separador se for PT-BR.
                        """)

            # Chamar IA (usando GPT-4)
            model = ChatOpenAI(model='gpt-4', temperature=0.3)
            resposta_ia = model.predict(prompt.format(csv_str=csv_str, descricao=descricao))

            # Converter resposta CSV da IA de volta para DataFrame
            df_modificado = pd.read_csv(io.StringIO(resposta_ia), sep=';' if ';' in resposta_ia else ',')


            # Gerar planilha Excel
            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                df_modificado.to_excel(writer, index=False, sheet_name='Dados')

                   # Aplicar formata√ß√£o num√©rica nas colunas num√©ricas
                worksheet = writer.sheets['Dados']
                number_format = writer.book.add_format({'num_format': '0'})
                for idx, col in enumerate(df_modificado.columns):
                    if pd.api.types.is_numeric_dtype(df_modificado[col]):
                        worksheet.set_column(idx, idx, None, number_format)

                # Gerar gr√°fico se necess√°rio
                if contem_pedido_grafico(descricao):
                    primeira_aba = list(processed_sheets.keys())[0]
                    df_modificado = processed_sheets[primeira_aba]
                    x_col, y_col = extrair_colunas_grafico(descricao, df_modificado.columns.tolist())
                    if x_col and y_col:
                        chart_type = extrair_tipo_grafico(descricao)
                        workbook = writer.book
                        worksheet = writer.sheets['Dados']

                        # Criar gr√°fico
                        chart = workbook.add_chart({'type': chart_type})
                        chart.add_series({
                            'categories': ['Dados', 1, df_modificado.columns.get_loc(x_col), len(df_modificado), df_modificado.columns.get_loc(x_col)],
                            'values': ['Dados', 1, df_modificado.columns.get_loc(y_col), len(df_modificado), df_modificado.columns.get_loc(y_col)],
                            'name': y_col,
                        })

                        # Configurar layout
                        chart.set_title({'name': f'{y_col} por {x_col}'})
                        chart.set_x_axis({'name': x_col})
                        chart.set_y_axis({'name': y_col})

                        # Adicionar em nova aba
                        chart_sheet = workbook.add_worksheet('Gr√°fico')
                        chart_sheet.insert_chart('B2', chart)

            # Aplicar formata√ß√£o condicional
            output.seek(0)
            regras = extrair_regras_formatacao(descricao)
            processed_sheets = [('Dados', df_modificado)]
            buffer_final = aplicar_regras_excel(regras, output, processed_sheets)

            # Preparar resposta final
            buffer_final.seek(0)
            planilha_modificada = buffer_final

            # Atualizar tokens usados
            user_profile.tokens_gastos += tokens_estimados
            user_profile.save()

            return JsonResponse({'success': True})

        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return JsonResponse({'error': str(e)}, status=500)

    return JsonResponse({'error': 'M√©todo n√£o permitido'}, status=405)

def download_planilha(request):
    global planilha_modificada

    if planilha_modificada:
        response = FileResponse(planilha_modificada, as_attachment=True, filename='planilha_modificada.xlsx')
        response['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        return response
    else:
        return JsonResponse({'error': 'Nenhuma planilha processada'}, status=404)
